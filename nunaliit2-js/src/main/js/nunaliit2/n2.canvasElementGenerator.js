/*
Copyright (c) 2015, Geomatics and Cartographic Research Centre, Carleton 
University
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, 
   this list of conditions and the following disclaimer.
 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
 - Neither the name of the Geomatics and Cartographic Research Centre, 
   Carleton University nor the names of its contributors may be used to 
   endorse or promote products derived from this software without specific 
   prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.

*/

;(function($,$n2) {
"use strict";

var 
 _loc = function(str,args){ return $n2.loc(str,'nunaliit2',args); }
 ,DH = 'n2.canvasElementGenerator'
;
 
// An instance of ElementGenerator is responsible of taking a set of documents
// from a data source and producing a set of graphic elements, based on those
// document, destined to a canvas.
//
// The instance of ElementGenerator is informed when the data set is changed and
// propagates those changes, in terms of elements, to the canvas. It is also
// responsible to keep track of user intents on the source documents, translate
// these intents in terms of elements and inform the canvas.
//
// In reverse, an instance of ElementGenerator is informed by the canvas when the user
// clicks or hovers an element. Then, it translates these intents from elements
// to documents and informs the remainder of the system by sending the appropriate
// events through the dispatcher.
//
// The algorithm used by instances of ElementGenerator is to break up documents into
// fragments and then combine the fragments into elements.
//
// Elements provided to the canvas have the following attributes:
// {
//     id: String. Unique identifier for this element
//     fragments: Array of Objects. Used internally by ElementGenerator
//     n2_selected: Boolean. Set if element is selected
//     n2_selectedIntent: String. Selection intent, if one is specified.
//     n2_hovered: Boolean. Set if element is in focus
//     n2_hoveredIntent: String. Focus intent, if one is specified.
//     n2_found: Boolean. Set if the element is found.
//     n2_intent: String. Effective intention (selected or hovered), if one is specified.
//     n2_doc: Optional Object. Document, if only one is associated with the element.
// }
 
//--------------------------------------------------------------------------
// doc 1---1 context 1---N fragment N---N element
//
// doc
//   must have the following attributes:
//      _id
//
// context
//   must have the following attributes:
//      n2_id : document identifier for the supporting document
//      n2_doc : supporting document
//      fragments : list of fragments generated from supporting document
//
// fragment
//   must have the following attributes:
//      id : unique identifier for fragment
//      n2_id : document identifier for the supporting document
//      n2_doc : supporting document
//      context : context associated with supporting document
//      elements : element map, by element id, for each element associated 
//                 with the fragment
//
// element
//   must have the following attributes:
//      id : unique identifier for element
//      fragments : map of fragments, by fragment id, making up element
var ElementGenerator = $n2.Class('ElementGenerator', {
	
	elementsChanged: null,
	
	intentChanged: null,
	
	contextByDocId: null,

	fragmentById: null,

	elementById: null,
	
	dispatchService: null,
	
	userIntentView: null,
	
	/*
	 * This is a string or object used to set all the attribute "_source" on all events
	 * generated by this element generator. It should be set by the canvas that the element
	 * generator represents. This is useful to determine if an event was produced by
	 * the canvas, or not.
	 */
	eventSource: null,
	
	initialize: function(opts_){
		var opts = $n2.extend({
			dispatchService: null
			,eventSource: null
			,elementsChanged: function(added, updated, removed){}
			,intentChanged: function(updated){}
		},opts_);
		
		var _this = this;
		
		this.elementsChanged = opts.elementsChanged;
		this.intentChanged = opts.intentChanged;
		
		this.docs = [];
		this.docIds = [];
		this.multiSelect = false;

		this.contextByDocId = {};
		this.fragmentById = {};
		this.elementById = {};
		
		this.eventSource = undefined;
		if( opts.eventSource ){
			this.eventSource = opts.eventSource;
		};
	
		this.dispatchService = opts.dispatchService;
		
		this.userIntentView = new $n2.userIntentView.IntentView({
			dispatchService: opts.dispatchService
		});
		this.userIntentView.addListener(function(changedNodes){
			_this._intentChangedContexts(changedNodes);
		});
	},
	
	setElementsChangedListener: function(listener){
		this.elementsChanged = listener;
	},
	
	setIntentChangedListener: function(listener){
		this.intentChanged = listener;
	},
	
	setEventSource: function(eventSource){
		this.eventSource = eventSource;
	},

	setMultiSelect: function(multiSelect) {
		this.multiSelect = multiSelect;
	},
	
	/*
	 * This function gets called when changes in the underlying documents
	 * are detected.
	 */
	sourceModelUpdated: function(opts_){
 		var opts = $n2.extend({
 			added: null
 			,updated: null
 			,removed: null
 		},opts_);
 		
 		//$n2.log('sourceModelUpdated',opts);

 		var contextsAdded = [];
 		var contextsUpdated = [];
 		var contextsRemoved = [];

 		if( opts.added ){
 			for(var i=0,e=opts.added.length; i<e; ++i){
 				var doc = opts.added[i];

 				var context = {
 					n2_id: doc._id
					,n2_doc: doc
					,fragments: []
 				};
 				contextsAdded.push(context);
 				
 				this.contextByDocId[doc._id] = context;
 			};
 		};

 		if( opts.updated ){
 			for(var i=0,e=opts.updated.length; i<e; ++i){
 				var doc = opts.updated[i];

 				var context = this.contextByDocId[doc._id];
 				if( context ){
					context.n2_doc = doc;
					contextsUpdated.push(context);
 					
 				} else {
 	 				var context = {
 	 					n2_id: doc._id
 						,n2_doc: doc
 						,fragments: []
 	 				};
 	 				contextsAdded.push(context);
 	 				
 	 				this.contextByDocId[doc._id] = context;
 				};
 			};
 		};

 		if( opts.removed ){
 			for(var i=0,e=opts.removed.length; i<e; ++i){
 				var doc = opts.removed[i];

 				var context = this.contextByDocId[doc._id];
 				if( context ){
 					delete this.contextByDocId[doc._id];
 					contextsRemoved.push(context);
 				};
 			};
 		};

 		// Before fragments and elements are created, update contexts with user
 		// intent
		if( contextsRemoved 
		 && contextsRemoved.length ){
			this.userIntentView.removeNodes(contextsRemoved);
		};
		if( contextsAdded 
		 && contextsAdded.length ){
			this.userIntentView.addNodes(contextsAdded);
		};

 		if( contextsAdded.length > 0 
 		 || contextsUpdated.length > 0 
 		 || contextsRemoved.length > 0 ){
 			this._contextsUpdated(contextsAdded, contextsUpdated, contextsRemoved);
 		};
 		
	},

	/*
	 * This method is called by the canvas to indicate that an element
	 * has been selected.
	 */
	selectOn: function(element){
		if( element ){
			var docsById = this._docsFromElement(element);
			
			if(!this.multiSelect) {
				this.docs = [];
				this.docIds = [];
			}

			for(var docId in docsById){
				var doc = docsById[docId];
				this.docIds.push(docId);
				this.docs.push(doc);
			};
			
			if( this.docIds.length < 1 ){
				this.dispatchService.send(DH,{
					type: 'userUnselect'
					,_source: this.eventSource
				});
			} else if( this.docIds.length == 1 ){
				this.dispatchService.send(DH,{
					type: 'userSelect'
					,docId: this.docIds[0]
					,doc: this.docs[0]
					,_source: this.eventSource
				});
			} else if( this.docIds.length > 1 ){
				this.dispatchService.send(DH,{
					type: 'userSelect'
					,docIds: this.docIds
					,docs: this.docs
					,_source: this.eventSource
				});
			}
		}
	},

	/*
	 * This method is called by the canvas to indicate that an element
	 * has been unselected.
	 */
	selectOff: function(element){
		if( element ){
			var docsById = this._docsFromElement(element);

			for(var docId in docsById){
				this.docIds = this.docIds.filter(function(arrDocId) {
					return arrDocId !== docId;
				})
				this.docs = this.docs.filter(function(doc) {
					return doc._id !== docId;
				})
			}

			if( this.docIds.length < 1 ){
				this.dispatchService.send(DH,{
					type: 'userUnselect'
					,docId: this.docIds[0]
					,doc: this.docs[0]
					,_source: this.eventSource
				});
			} else if( this.docIds.length == 1 ){
				this.dispatchService.send(DH,{
					type: 'userSelect'
					,docId: this.docIds[0]
					,doc: this.docs[0]
					,_source: this.eventSource
				});
			} else if( this.docIds.length > 1 ){
				this.dispatchService.send(DH,{
					type: 'userSelect'
					,docIds: this.docIds
					,docs: this.docs
					,_source: this.eventSource
				});
			}

		};
	},

	/* This method is called by the canvas to unselect all elements */
	selectAllOff: function() {
		this.dispatchService.send(DH, { type: 'userUnselect' });
		this.docIds = [];
		this.docs = [];
	},
	
	isSelected: function(element) {
		if( element ){
			var docsById = this._docsFromElement(element);
			for(var docId in docsById){
				if(this.docIds.includes(docId)) {
					return true;
				}
			}
		}
		return false;
	},
	/*
	 * This method is called by the canvas to indicate that an element
	 * is hovered by the user (in focus).
	 */
	focusOn: function(element){
		if( element ){
			var docsById = this._docsFromElement(element);
			
			var docIds = [];
			var docs = [];
			for(var docId in docsById){
				var doc = docsById[docId];
				docIds.push(docId);
				docs.push(doc);
			};
			
			if( docIds.length > 1 ){
				this.dispatchService.send(DH,{
					type: 'userFocusOn'
					,docIds: docIds
					,docs: docs
					,_source: this.eventSource
				});

			} else if( docIds.length > 0 ){
				this.dispatchService.send(DH,{
					type: 'userFocusOn'
					,docId: docIds[0]
					,doc: docs[0]
					,_source: this.eventSource
				});
			};
		};
	},

	/*
	 * This method is called by the canvas to indicate that an element
	 * is no longer hovered by the user (out of focus).
	 */
	focusOff: function(element){
		if( element ){
			var docsById = this._docsFromElement(element);

			for(var docId in docsById){
				var doc = docsById[docId];
				this.dispatchService.send(DH,{
					type: 'userFocusOff'
					,docId: docId
					,doc: doc
					,_source: this.eventSource
				});
			};
		};
	},
	
	/*
	 * This gets called as a result of changes in the underlying documents. It
	 * recomputes the fragments from the documents.
	 */
	_contextsUpdated: function(contextsAdded, contextsUpdated, contextsRemoved){

		var fragmentsAdded = [];
		var fragmentsRemoved = [];
		
		if( contextsAdded || contextsUpdated ){
			var addedAndUpdated = [];
			if( contextsAdded ){
				addedAndUpdated.push.apply(addedAndUpdated, contextsAdded);
			};
			if( contextsUpdated ){
				addedAndUpdated.push.apply(addedAndUpdated, contextsUpdated);
			};
			
 			for(var i=0,e=addedAndUpdated.length; i<e; ++i){
 				var context = addedAndUpdated[i];

 				var previousFragments = context.fragments;
 				
 				for(var fragIndex=0; fragIndex<previousFragments.length; ++fragIndex){
 					var frag = previousFragments[fragIndex];
 					fragmentsRemoved.push(frag);
 				};

 				// _createFragmentsFromDoc() is implemented by all subclasses
 				context.fragments = this._createFragmentsFromDoc(context.n2_doc);
 				
 				for(var fragIndex=0; fragIndex<context.fragments.length; ++fragIndex){
 					var frag = context.fragments[fragIndex];
 					frag.context = context;
 					fragmentsAdded.push(frag);
 				};
 			};
 		};
 		
		if( contextsRemoved ){
 			for(var i=0,e=contextsRemoved.length; i<e; ++i){
 				var context = contextsRemoved[i];

 				var previousFragments = context.fragments;
 				
 				for(var fragIndex=0; fragIndex<previousFragments.length; ++fragIndex){
 					var frag = previousFragments[fragIndex];
 					fragmentsRemoved.push(frag);
 				};
 			};
		};

		for(var fragIndex=0; fragIndex<fragmentsRemoved.length; ++fragIndex){
			var frag = fragmentsRemoved[fragIndex];
			frag.context = null;
		};
		
		if( fragmentsAdded.length > 0 
		 || fragmentsRemoved.length > 0 ){
			this._fragmentsUpdated(fragmentsAdded, fragmentsRemoved);
		};
	},
	
	/**
	 * This method should be re-implemented by sub-classes to establish other representations.
	 * 
	 * This method is used to create a set of fragments given a document. A document can generate
	 * 0, 1 or multiple fragments. A fragment should have an id that differentiate it from
	 * all other fragments. It is a good idea to derive the fragment id from the document id
	 * to avoid collision.
	 * 
	 * A fragment created by this method should have at least the following properties:
	 * {
	 *    id : unique identifier for fragment
	 *    n2_id : document identifier for the supporting document
	 *    n2_doc : supporting document
	 * }
	 * 
	 * @param doc Object. Document that fragments should be generated from
	 * @return Array of fragments.
	 * 
	 */
	_createFragmentsFromDoc: function(doc){
		throw new Error('Sub-classes to ElementGenerator must implement _createFragmentsFromDoc()');
	},
	
	/*
	 * This function is called when the set of fragments have changed. This is
	 * ultimately due because of changes in the underlying documents.
	 */
	_fragmentsUpdated: function(fragmentsAdded, fragmentsRemoved){
		
		// Update fragment map
		for(var fragIndex=0; fragIndex<fragmentsRemoved.length; ++fragIndex){
			var frag = fragmentsRemoved[fragIndex];
			var fragId = frag.id;
			frag.elements = {};
			if( this.fragmentById[fragId] ){
				delete this.fragmentById[fragId];
			};
		};
		for(var fragIndex=0; fragIndex<fragmentsAdded.length; ++fragIndex){
			var frag = fragmentsAdded[fragIndex];
			var fragId = frag.id;
			this.fragmentById[fragId] = frag;
		};
		
		// Reset elements on fragments
		for(var fragId in this.fragmentById){
			var frag = this.fragmentById[fragId];
			frag.elements = {};
		};
		
		// Create elements from fragments
		var currentElementMap = {};
		for(var elementId in this.elementById){
			var element = this.elementById[elementId];
			currentElementMap[elementId] = element;
			
			// Remove previous fragments, we are about to get new ones
			element.fragments = {};
		};
		var newElementMap = this._updateElements(this.fragmentById, currentElementMap);
		
		// Assign elements to fragments
		for(var elementId in newElementMap){
			var element = newElementMap[elementId];

			for(var fragId in element.fragments){
				var frag = element.fragments[fragId];
				if( typeof frag.elements === 'undefined' ){
					$n2.log('Undefined elements');
				};
				frag.elements[elementId] = element;
			};
		};
		
		var elementsAdded = [];
		var elementsUpdated = [];
		var elementsRemoved = [];
		
		for(var elementId in this.elementById){
			if( typeof newElementMap[elementId] === 'undefined' ){
				elementsRemoved.push( this.elementById[elementId] );
			};
		};
		
		for(var elementId in newElementMap){
			if( typeof this.elementById[elementId] === 'undefined' ){
				elementsAdded.push( newElementMap[elementId] );
			} else {
				elementsUpdated.push( newElementMap[elementId] );
			};
		};
		
		this.elementById = newElementMap;
		
		// Fix style information
		for(var elementId in this.elementById){
			var element = this.elementById[elementId];
			this._adjustElementIntent(element);
		};
		
		//$n2.log('elementsChanged',elementsAdded, elementsUpdated, elementsRemoved);
		
		this.elementsChanged(elementsAdded, elementsUpdated, elementsRemoved);
	},
	
	/**
	 * This method takes a map of all fragments (fragments by identifier) and a map of
	 * the current elements (elements by identifier). Then, it computes a new set of elements 
	 * based on the fragments.
	 * 
	 * Each element created by this function should have at least the following properties:
	 * {
	 *    id : unique identifier for element
	 *    fragments : map of fragments, by fragment id, making up element
	 * }
	 *  
	 * Sub-classes should re-implement this method.
	 * 
	 * @param fragmentMap Dictionary of fragments, by fragment id
	 * @param currentElementMap Dictionary of current elements, by element id
	 * @return Dictionary of new elements, by element id
	 */
	_updateElements: function(fragmentMap, currentElementMap){
		if( typeof this._createClusters === 'function' ){
			// Support legacy implementations
			$n2.log('ElementGenerator._createClusters() is deprecated. Use _updateElements().');
			this.clusterById = currentElementMap;
			return this._createClusters(fragmentMap);
		};
		
		throw new Error('Subclasses of ElementGenerator should implement _updateElements()');
	},
	
	/*
	 * Given an element, re-compute the element's state based on the supporting
	 * contexts. By default, this method marks an element selected if any of its
	 * fragment is selected. The same is true with the hovered state.
	 * 
	 * As far as intents are concerned, the intent of a fragment is copied to the
	 * element unles it collides with a different fragment, at which point the result
	 * is null.
	 * 
	 * Sub-classes should re-implement this method if a different behaviour is required.
	 */
	_adjustElementIntent: function(element){
		element.n2_selected = false;
		element.n2_selectedIntent = undefined;
		element.n2_hovered = false;
		element.n2_hoveredIntent = undefined;
		element.n2_found = false;
		element.n2_intent = undefined;
		
		if( element.fragments ){
			for(var fragId in element.fragments){
				var fragment = element.fragments[fragId];
				var context = fragment.context;
				
				if( context ){
					if( context.n2_selected ){
						element.n2_selected = true;
					};
					if( context.n2_hovered ){
						element.n2_hovered = true;
					};
					if( context.n2_found ){
						element.n2_found = true;
					};
					if( context.n2_selectedIntent ){
						if( element.n2_selectedIntent === null ){
							// collision
						} else if( element.n2_selectedIntent === undefined ){
							element.n2_selectedIntent = context.n2_selectedIntent;
						} else {
							element.n2_selectedIntent = null;
						};
					};
					if( context.n2_hoveredIntent ){
						if( element.n2_hoveredIntent === null ){
							// collision
						} else if( element.n2_hoveredIntent === undefined ){
							element.n2_hoveredIntent = context.n2_hoveredIntent;
						} else {
							element.n2_hoveredIntent = null;
						};
					};
					if( context.n2_intent ){
						if( element.n2_intent === null ){
							// collision
						} else if( element.n2_intent === undefined ){
							element.n2_intent = context.n2_intent;
						} else {
							element.n2_intent = null;
						};
					};
				};
			};
		};
	},
	
	/*
	 * This method is called by the UserIntentView to notify changes
	 * in the user intent. The input array contains instances of context.
	 */
	_intentChangedContexts: function(changedContextNodes){
		// Accumulate all elements from document contexts
		var changedElementMap = {};
		for(var ci=0,ce=changedContextNodes.length; ci<ce; ++ci){
			var context = changedContextNodes[ci];
			for(var fi=0,fe=context.fragments.length; fi<fe; ++fi){
				var fragment = context.fragments[fi];
				if( fragment.elements ){
					for(var elementId in fragment.elements){
						var element = fragment.elements[elementId];
						changedElementMap[elementId] = element;
					};
				};
			};
		};

		// Adjust all intentions on elements
		var changedElements = [];
		for(var elementId in changedElementMap){
			var element = changedElementMap[elementId];
			this._adjustElementIntent(element);
			changedElements.push(element);
		};
		
		// Report changes
		if( changedElements.length ){
			this.intentChanged(changedElements);
		};
	},
	
	/*
	 * This function returns a map all the documents, indexed by document identifier,
	 * associated with an element.
	 */
	_docsFromElement: function(element_){
		var element = element_;
		if( typeof element === 'string' ){
			element = this.elementById[element];
		};

		var docsById = {};
		if( element && element.fragments ){
			for(var fragId in element.fragments){
				var fragment = element.fragments[fragId];
				var context = fragment.context;

				var doc = null;
				if( context ){
					doc = context.n2_doc;
				};
				
				var docId = null;
				if( doc ){
					docId = doc._id;
				};

				if( docId ){
					docsById[docId] = doc;
				};
			};
		};
		
		return docsById;
	}
});

//--------------------------------------------------------------------------
// This instance of ElementGenerator contribute the following attributes to the
// generated elements:
// {
//     isNode: Boolean. Set for documents
//     isLink: Boolean. Set for reference between two documents
//     n2_doc: Object. Copy of document for nodes
//     n2_geometry: String. Set to 'point' for nodes, and 'line' for reference
//     source: Object. Source element in case of a reference
//     target: Object. Target element in case of a reference
// }
var GenericElementGenerator = $n2.Class('GenericElementGenerator', ElementGenerator, {

	initialize: function(opts_){
		ElementGenerator.prototype.initialize.call(this, opts_);
	},
	
	/*
	 * This method is used to create a set of fragments given a document. The default
	 * implementation is to create a node for each document and a link for each reference
	 * to other document.
	 */
	_createFragmentsFromDoc: function(doc){
		var fragments = [];
		
		var node = {
			isNode: true
			,id: 'node_'+doc._id
			,n2_id: doc._id
			,n2_doc: doc
			,n2_geometry: 'point'
		};
		fragments.push(node);
		
 		// Create links for references
 		var refDocIds = {};
 		var references = [];
 		$n2.couchUtils.extractLinks(doc, references);
 		for(var i=0,e=references.length; i<e; ++i){
 			var ref = references[i];
 			if( ref.doc ){
 				refDocIds[ref.doc] = true;
 			};
 		};
 		for(var refDocId in refDocIds){
 			var link = {
 				isLink: true
 	 			,id: 'link_' + doc._id + '_' + refDocId
 	 			,n2_id: doc._id
 	 			,n2_doc: doc
 	 			,n2_geometry: 'line'
 			};
 			
 			var sourceId = doc._id;
 			var targetId = refDocId;

			link.sourceId = sourceId;
			link.targetId = targetId;

 			fragments.push(link);
 		};
 		
		return fragments;
	},

	/*
	 * This method takes a map of all fragments (fragments by identifier) and computes
	 * a set of elements based on the fragments.
	 * 
	 * By default, it creates one element for each fragment node. It also creates an element
	 * for each link where the source and target are present.
	 */
	_updateElements: function(fragmentMap, currentElementMap){
		var newElementMap = {};

		// Create nodes
		var nodeMap = {};
		for(var fragId in fragmentMap){
			var frag = fragmentMap[fragId];
			
			if( frag.isNode ){
				var element = currentElementMap[frag.id];
				if( !element ){
					element = {
						id: fragId
						,fragments: {}
					};
				};
				
				element.fragments[fragId] = frag;
				element.n2_id = frag.context.n2_id;
				element.n2_doc = frag.context.n2_doc;
				element.n2_geometry = 'point';
				element.isLink = false;
				element.isNode = frag.isNode;
				
				newElementMap[element.id] = element;
				
				nodeMap[frag.context.n2_id] = element;
			};
		};

		// Create links
		for(var fragId in fragmentMap){
			var frag = fragmentMap[fragId];
			
			if( frag.isLink 
			 && nodeMap[frag.sourceId] 
			 && nodeMap[frag.targetId] ){
				var elementId = fragId;
				var element = currentElementMap[elementId];
				if( !element ){
					element = {
						id: elementId
						,fragments: {}
					};
				};
				
				element.fragments[frag.id] = frag;
				element.n2_id = frag.context.n2_id;
				element.n2_doc = frag.context.n2_doc;
				element.n2_geometry = 'line';
				element.isLink = frag.isLink;
				element.isNode = false;
				element.source = nodeMap[frag.sourceId];
				element.target = nodeMap[frag.targetId];

				newElementMap[element.id] = element;
			};
		};

		return newElementMap;
	}
});

//--------------------------------------------------------------------------
// The elements generated by this instance of ElementGenerator are similar
// to the GenericElementGenerator. However, duplication of links (references
// between documents) are combined into one element.
//
// This instance of ElementGenerator contribute the following attributes to the
// generated elements:
// {
//   isNode: Boolean. Set for documents
//   isLink: Boolean. Set for reference between two documents
//   n2_doc: Object. Copy of document for nodes
//   n2_geometry: String. Set to 'point' for nodes, and 'line' for reference
//   source: Object. Source element in case of a reference
//   target: Object. Target element in case of a reference
//   count: Integer. For links, the number of links that have been merged
// }
var GroupLinks = $n2.Class('GroupLinks', GenericElementGenerator, {
	initialize: function(opts_){
		GenericElementGenerator.prototype.initialize.call(this, opts_);
	},
	
	_updateElements: function(fragmentMap, currentElementMap){
		var newElementMap = {};
		
		var nodeMap = {};
		var fragMap = {};
		for(var fragId in fragmentMap){
			var frag = fragmentMap[fragId];
			
			if( frag.isNode ){
				var element = currentElementMap[frag.id];
				if( !element ){
					element = {
						id: fragId
						,fragments: {}
					};
				};
				
				element.fragments[fragId] = frag;
				element.n2_id = frag.context.n2_id;
				element.n2_doc = frag.context.n2_doc;
				element.n2_geometry = 'point';
				element.isLink = frag.isLink;
				element.isNode = frag.isNode;
				
				newElementMap[element.id] = element;
				
				nodeMap[frag.context.n2_id] = element;
				fragMap[frag.context.n2_id] = frag;
			};
		};

		var linkClustersById = {};
		for(var fragId in fragmentMap){
			var frag = fragmentMap[fragId];
			
			if( frag.isLink 
			 && nodeMap[frag.sourceId] 
			 && nodeMap[frag.targetId] ){
				var elementId = [frag.sourceId,frag.targetId].sort().join('|');
				var element = linkClustersById[elementId];
				if( !element ){
					element = currentElementMap[elementId];
				};
				if( !element ){
					element = {
						id: elementId
						,fragments: {}
						,count: 0
					};
				};
				newElementMap[elementId] = element;
				linkClustersById[elementId] = element;
				
				element.fragments[frag.id] = frag;
				element.n2_id = frag.context.n2_id;
				element.n2_doc = frag.context.n2_doc;
				element.n2_geometry = 'line';
				element.isLink = frag.isLink;
				element.isNode = frag.isNode;
				element.count = element.count + 1;
				element.source = nodeMap[frag.sourceId];
				element.target = nodeMap[frag.targetId];
				
				// Associate the document node fragments with this element
				{
					var nodeFrag = fragMap[frag.sourceId]; 
					element.fragments[nodeFrag.id] = nodeFrag;
				};
				{
					var nodeFrag = fragMap[frag.targetId]; 
					element.fragments[nodeFrag.id] = nodeFrag;
				};
			};
		};

		return newElementMap;
	}
});

//--------------------------------------------------------------------------
var elementGeneratorFactoriesByType = {};

function AddElementGeneratorFactory(opts_){
	var opts = $n2.extend({
		type: null
		,factoryFn: null
	},opts_);
	
	var type = opts.type;
	var factoryFn = opts.factoryFn;
	
	if( typeof type === 'string' 
	 && typeof factoryFn === 'function' ){
		elementGeneratorFactoriesByType[type] = factoryFn;
		
	} else {
		$n2.log('Unable to register ElementGenerator factory: '+opts.type);
	};
};

function CreateElementGenerator(opts_){
	var opts = $n2.extend({
		type: null
		,options: null
		,config: null
	},opts_);
	
	var type = opts.type;
	var options = opts.options;
	var config = opts.config;
	
	var elementGenerator = null;
	
	// Default
	if( 'default' === type 
	 && config 
	 && config.directory 
	 && config.directory.dispatchService ){
		elementGenerator = new GenericElementGenerator({
			dispatchService: config.directory.dispatchService
			,options: options
		});
	};
	
	// GroupLinks
	if( !elementGenerator 
	 && 'GroupLinks' === type 
	 && config 
	 && config.directory 
	 && config.directory.dispatchService ){
		elementGenerator = new GroupLinks({
			dispatchService: config.directory.dispatchService
			,options: options
		});
	};

	// Custom
	if( !elementGenerator 
	 && elementGeneratorFactoriesByType[type]
	 && config ){
		var factoryFn = elementGeneratorFactoriesByType[type];
		elementGenerator = factoryFn({
			type: type
			,options: options
			,config: config
		});
	};
	
	// Fallback on default
	if( !elementGenerator 
	 && config 
	 && config.directory 
	 && config.directory.dispatchService ){
		
		$n2.log('Type of ElementGenerator not recognized: '+type);
		
		elementGenerator = new GenericElementGenerator({
			dispatchService: config.directory.dispatchService
			,options: options
		});
	};
	
	return elementGenerator;
};

//--------------------------------------------------------------------------
$n2.canvasElementGenerator = {
	CreateElementGenerator: CreateElementGenerator
	,AddElementGeneratorFactory: AddElementGeneratorFactory
	,ElementGenerator: ElementGenerator
	,GenericElementGenerator: GenericElementGenerator
	,GroupLinks: GroupLinks
};

})(jQuery,nunaliit2);
